{
    "analyticsRule": [
        {
            "searchKey": "6f675c17-7a61-440c-abd1-c73ef4d748ec",
            "displayName": "Creation of CRUD DynamoDB policy and then privilege escalation.",
            "description": "Detected creation of new CRUD DynamoDB policy and usage of one of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and ((Action contains \"dynamodb:Create\" or Action contains \"dynamodb:Put\") and (Action contains \"dynamodb:Describe\" or Action contains \"dynamodb:Get\" or Action contains \"dynamodb:Scan\")  and Action contains \"dynamodb:Update\" and Action contains \"dynamodb:Delete\") and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, SourceIpAddress, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"SourceIpAddress\", SourceIpAddress, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, AttachEventCount, RecipientAccountId, AccountName, AccountUPNSuffix);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "454133a7-5427-4a7c-bdc4-0adfa84dda16",
            "displayName": "Creating keys with encrypt policy without MFA",
            "description": "Detection of KMS keys where action kms:Encrypt is accessible for everyone (also outside of your organization). This is an idicator that your account is compromised and the attacker uses the encryption key to compromise another company.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let check_actions = AWSCloudTrail| where (EventName == \"CreateKey\" or EventName == \"PutKeyPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| extend state=parse_json(parse_json(replace_string(tostring(parse_json(RequestParameters)['policy']),'\\\\\"','\"')).['Statement'])| mv-expand state| extend Action= tostring(parse_json(state.['Action'][0])), Effect=tostring(parse_json(state.['Effect'])),         Principal=tostring(parse_json(state.['Principal']))| where (Action == \"kms:Encrypt\" or Action == \"kms:*\") and (Effect == 'Allow') and (Principal has \"*\")| distinct AwsEventId;AWSCloudTrail| where (EventName == \"CreateKey\" or EventName == \"PutKeyPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| join kind=inner (check_actions) on AwsEventId| extend timestamp = TimeGenerated| project-away AwsEventId1",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Impact"
            ],
            "tacticsMultiple": "Impact",
            "techniques": [
                "T1485"
            ],
            "techniquesMultiple": "T1485",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "a694e977-740c-4578-9f8f-5e39029f1d23",
            "displayName": "Creation of EC2 policy and then privilege escalation",
            "description": "Detected creation of new EC2 policy and afterwards used one of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and ((((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"ec2:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"ec2:RunInstances\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"ec2:Run*\")) or (Action contains \"ec2:*\") or (Action contains \"ec2:ListInstances\" and Action contains \"ec2:StartInstance\" and Action contains \"ec2:ModifyInstanceAttribute\") or (Action contains \"ec2:List*\" and Action contains \"ec2:Start*\" and Action contains \"ec2:Modify*\")) and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType,  \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn, \"SourceIpAddress\", SourceIpAddress)| project EventSource, PolicyName, AttachEvent, RecipientAccountId, AccountName, AccountUPNSuffix, AttachEventCount);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "826bb2f8-7894-4785-9a6b-a8a855d8366f",
            "displayName": "Full Admin policy created and then attached to Roles, Users or Groups",
            "description": "Identity and Access Management (IAM) securely manages access to AWS services and resources.Identifies when a policy is created with Full Administrators Access (Allow-Action:,Resource:).This policy can be attached to role,user or group and may be used by an adversary to escalate a normal user privileges to an adminsitrative level.AWS IAM Policy Grammar: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.htmland AWS IAM API at https://docs.aws.amazon.com/IAM/latest/APIReference/API_Operations.html",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy = dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource)| mvexpand Action| extend Action = tostring(Action)| where Effect =~ \"Allow\" and Action == \"*\" and Resource == \"*\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, UserIdentityUserName, RecipientAccountId, AccountName, AccountUPNSuffix| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn, \"SourceIpAddress\", SourceIpAddress)| project EventSource, PolicyName, AttachEvent, RecipientAccountId, AccountName, AccountUPNSuffix, AttachEventCount);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "14 days",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation",
                "Defense Evasion"
            ],
            "tacticsMultiple": "Privilege Escalation1\ue946Defense Evasion",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.4",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "d0953d50-3dc1-4fa3-80fa-4d3e973a0959",
            "displayName": "Privilege escalation via CRUD Lambda policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy by CRUD Lambda policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Action contains \"lambda:Create\" and Action contains \"lambda:Get\" and Action contains \"lambda:Update\" and Action contains \"kms:Delete\") and Resource == \"*\" and Condition == \"\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "8f1630c2-2e45-4df2-be43-50fba90f601d",
            "displayName": "RDS instance publicly exposed",
            "description": "Detected publicly exposed RDS instance, which could lead to a leakage of sensitive data.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where  EventName in (\"CreateDBInstance\", \"ModifyDBInstance\") and isempty(ErrorCode) and isempty(ErrorMessage)| where tostring(parse_json(RequestParameters).publiclyAccessible) == \"true\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 hour",
            "rulePeriod": "1 hour",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Exfiltration"
            ],
            "tacticsMultiple": "Exfiltration",
            "techniques": [
                "T1537"
            ],
            "techniquesMultiple": "T1537",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "9da99021-d318-4711-a78a-6dea76129b3a",
            "displayName": "GuardDuty detector disabled or suspended",
            "description": "GuardDuty Detector was disabled or suspended, possibly by an attacker trying to avoid detection of its malicious activities. Verify with the user identity that this activity is legitimate.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "AWSCloudTrail| where (EventName == \"DeleteDetector\" and isempty(ErrorCode) and isempty( ErrorMessage)) or (EventName == \"UpdateDetector\" and tostring(parse_json(RequestParameters).enable) == \"false\" and isempty(ErrorCode) and isempty( ErrorMessage))| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Defense Evasion"
            ],
            "tacticsMultiple": "Defense Evasion",
            "techniques": [
                "T1562"
            ],
            "techniquesMultiple": "T1562",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "719d5204-10ab-4b1f-aee1-da7326750260",
            "displayName": "Privilege escalation via CloudFormation policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on CloudFormation policy. Attackers could use these events for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail  | where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)  | extend PolicyName = tostring(parse_json(RequestParameters).policyName)  | extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement  | mvexpand Statement  | extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)  | extend Action = tostring(Action)  | where Effect =~ \"Allow\" and (((Action has \"iam:*\" or Action has \"iam:PassRole\") and Action has \"cloudformation:*\") or ((Action has \"iam:*\" or Action has \"iam:PassRole\") and Action contains \"cloudformation:DescribeStacks\" and Action contains \"cloudformation:CreateStack\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"cloudformation:Describe*\" and Action contains \"cloudformation:Create*\")) and Resource == \"*\" and Condition == \"\"  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)  | extend UserName = tostring(split(UserIdentityArn, '/')[-1])  | extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)  | extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName  | extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "796a45ee-220b-42be-8415-c8c933cf3b6d",
            "displayName": "Creation of Lambda policy and then privilege escalation",
            "description": "Detected creation of new Lambda policy and usage of one of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);  let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and ((((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:CreateFunction\" and Action contains \"lambda:InvokeFunction\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:Create*\" and Action contains \"lambda:Invoke*\")) or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:*\" and Action contains \"dynamodb:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:CreateFunction\" and Action contains \"lambda:CreateEventSourceMapping\" and Action contains \"dynamodb:PutItem\" and Action contains \"dynamodb:CreateTable\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:Create*\" and Action contains \"dynamodb:Put*\" and Action contains \"dynamodb:Create*\")) and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix,  PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"SourceIpAddress\", SourceIpAddress, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, RecipientAccountId, AccountName, AccountUPNSuffix, AttachEventCount);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "d7c39e15-997f-49e5-a782-73bf07db8aa5",
            "displayName": "Privilege escalation via CRUD KMS policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy by CRUD KMS policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Action contains \"kms:Create\" and (Action contains \"kms:Get\" or Action contains \"kms:Describe\")  and (Action contains \"kms:Disable\" or Action contains \"kms:Enable\") and Action contains \"kms:Delete\") and Resource == \"*\" and Condition == \"\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "b9be2aa6-911d-4131-8658-d2a537ed49f4",
            "displayName": "Privilege escalation via CRUD DynamoDB policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy by CRUD DynamoDB Policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and ((Action contains \"dynamodb:Create\" or Action contains \"dynamodb:Put\") and (Action contains \"dynamodb:Describe\" or Action contains \"dynamodb:Get\" or Action contains \"dynamodb:Scan\")  and Action contains \"dynamodb:Update\" and Action contains \"dynamodb:Delete\") and Resource == \"*\" and Condition == \"\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "6b9b4ee6-f4c1-4b86-8c8c-beb0bb59ae44",
            "displayName": "S3 bucket exposed via ACL",
            "description": "Detected S3 bucket publicly exposed via ACL, which could lead for sensitive information leakage to the public. Verify the S3 object configurations.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName == \"PutBucketAcl\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend Grant = parse_json(tostring((parse_json(RequestParameters).AccessControlPolicy))).AccessControlList.Grant| mvexpand Grant| extend cannedacl = parse_json(tostring((parse_json(RequestParameters))))| extend URI = parse_json(Grant).Grantee.URI, type = parse_json(Grant).Grantee.[\"xsi:type\"], xamzacl = parse_json(cannedacl).[\"x-amz-acl\"]| where (type == \"Group\" and (URI endswith \"AllUsers\" or URI endswith \"AuthenticatedUsers\"))  or xamzacl in (\"authenticated-read\",\"public-read\",\"public-read-write\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 hour",
            "rulePeriod": "1 hour",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Exfiltration"
            ],
            "tacticsMultiple": "Exfiltration",
            "techniques": [
                "T1537"
            ],
            "techniquesMultiple": "T1537",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "8e01c41d-bd4c-4bbe-aed5-18592735052d",
            "displayName": "Privilege escalation via Lambda policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on Lambda policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail  | where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)  | extend PolicyName = tostring(parse_json(RequestParameters).policyName)  | extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement  | mvexpand Statement  | extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)  | extend Action = tostring(Action)  | where Effect =~ \"Allow\" and ((((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:CreateFunction\" and Action contains \"lambda:InvokeFunction\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:Create*\" and Action contains \"lambda:Invoke*\")) or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:*\" and Action contains \"dynamodb:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:CreateFunction\" and Action contains \"lambda:CreateEventSourceMapping\" and Action contains \"dynamodb:PutItem\" and Action contains \"dynamodb:CreateTable\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"lambda:Create*\" and Action contains \"dynamodb:Put*\" and Action contains \"dynamodb:Create*\")) and Resource == \"*\" and Condition == \"\"  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)  | extend UserName = tostring(split(UserIdentityArn, '/')[-1])  | extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)  | extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName  | extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "c7bfadd4-34a6-4fa5-82f8-3691a32261e8",
            "displayName": "Changes to AWS Elastic Load Balancer security groups",
            "description": "Elastic Load Balancer distributes incoming traffic across multiple instances in multiple availability Zones. This increases the fault tolerance of your applications. Unwanted changes to Elastic Load Balancer specific security groups could open your environment to attack and  hence needs monitoring. More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255 and https://aws.amazon.com/elasticloadbalancing/. ",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Low",
            "query": "let EventNameList = dynamic([\"ApplySecurityGroupsToLoadBalancer\", \"SetSecurityGroups\"]);AWSCloudTrail| where EventName in~ (EventNameList)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize EventCount=count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated)by EventSource, EventName, UserIdentityType,  SourceIpAddress, UserAgent, SessionMfaAuthenticated, AWSRegion,AdditionalEventData, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, UserIdentityPrincipalid, ResponseElements| extend timestamp = StartTimeUtc",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Persistence"
            ],
            "tacticsMultiple": "Persistence",
            "techniques": [
                "T1098"
            ],
            "techniquesMultiple": "T1098",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "6009c632-94e9-4ffb-a11a-b4b99f457f88",
            "displayName": "Creation of DataPipeline policy and then privilege escalation.",
            "description": "Detected creation of new Datapipeline policy and usage of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"datapipeline:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"datapipeline:CreatePipeline\" and Action contains \"datapipeline:PutPipelineDefinition\" and Action contains \"datapipeline:ActivatePipeline\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"datapipeline:Create*\" and Action contains \"datapipeline:Put*\" and Action contains \"datapipeline:Activate*\")) and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn,  RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"SourceIpAddress\", SourceIpAddress, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, RecipientAccountId, AccountName, AccountUPNSuffix, AttachEventCount);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "8a607285-d95c-473d-8aab-59920de63af6",
            "displayName": "Creation of new CRUD IAM policy and then privilege escalation.",
            "description": "Detected creation of new CRUD IAM policy and usage of one of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Action contains \"iam:Create\" and (Action contains \"iam:Get\" or Action contains \"iam:List\")  and Action contains \"iam:Update\" and Action contains \"iam:Delete\") and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityType , UserIdentityArn, SourceIpAddress, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"SourceIpAddress\", SourceIpAddress,\"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, AttachEventCount, RecipientAccountId, AccountName, AccountUPNSuffix);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "65360bb0-8986-4ade-a89d-af3cf44d28aa",
            "displayName": "Changes to Amazon VPC settings",
            "description": "Amazon Virtual Private Cloud (Amazon VPC) lets you provision a logically isolated section of the AWS Cloud where you can launch AWS resources in a virtual network that you define.This identifies changes to Amazon VPC (Virtual Private Cloud) settings such as new ACL entries,routes, routetable or Gateways.More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255and AWS VPC API Docs: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/OperationList-query-vpc.html",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Low",
            "query": "let EventNameList = dynamic([\"CreateNetworkAclEntry\",\"CreateRoute\",\"CreateRouteTable\",\"CreateInternetGateway\",\"CreateNatGateway\"]);AWSCloudTrail| where EventName in~ (EventNameList)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent,UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements| extend timestamp = StartTimeUtc",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation",
                "Lateral Movement"
            ],
            "tacticsMultiple": "Privilege Escalation1\ue946Lateral Movement",
            "techniques": [
                "T1078",
                "T1563"
            ],
            "techniquesMultiple": "T10781\ue946T1563",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.5",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "4f19d4e3-ec5f-4abc-9e61-819eb131758c",
            "displayName": "Changes to AWS Security Group ingress and egress settings",
            "description": "A Security Group acts as a virtual firewall of an instance to control inbound and outbound traffic. Hence, ingress and egress settings changes to AWS Security Group should be monitored as these can expose the enviornment to new attack vectors.More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255. ",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Low",
            "query": "let EventNameList = dynamic([ \"AuthorizeSecurityGroupEgress\", \"AuthorizeSecurityGroupIngress\", \"RevokeSecurityGroupEgress\", \"RevokeSecurityGroupIngress\"]);AWSCloudTrail| where EventName in~ (EventNameList)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize EventCount=count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated)by EventSource, EventName, UserIdentityType, RecipientAccountId, AccountName, AccountUPNSuffix, SourceIpAddress, UserAgent, SessionMfaAuthenticated, AWSRegion,AdditionalEventData, UserIdentityAccountId, UserIdentityPrincipalid, ResponseElements| extend timestamp = StartTimeUtc",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Persistence"
            ],
            "tacticsMultiple": "Persistence",
            "techniques": [
                "T1098"
            ],
            "techniquesMultiple": "T1098",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "9e457dc4-81f0-4d25-bc37-a5fa4a17946a",
            "displayName": "Suspicious AWS EC2 Compute Resource Deployments",
            "description": "This detection focused on Suspicious deployment of AWS EC2 resource (virtual machine) scale sets was detected. This behavior might indicate that the threat actor is deploying computing resources for cryptocurrency mining activities.This detection centers around identifying suspicious instances of AWS EC2 resource deployment, particularly scale sets. Such behavior raises concerns of potential threat actor involvement, potentially indicative of efforts to deploy computing resources for the purpose of cryptocurrency mining activities",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "// Retrieve AWS CloudTrail events generated within the last dayAWSCloudTrail// Filter events related to instance creation| where EventName =~ \"RunInstances\"// Exclude events with error messages| where isempty(ErrorMessage)// Extract the event source type| extend EventSourceSplit = split(EventSource, \".\")| extend Type = tostring(EventSourceSplit[0])// Extract instance-related details from the event data| extend instance = tostring(parse_json(RequestParameters).instanceType),platform = tostring(parse_json(ResponseElements).instancesSet.items[0].platform)// Determine the operating system platform| extend OSplatform = iff(isempty(platform), tostring(\"Linux\"), platform),CPU = tostring(parse_json(ResponseElements).instancesSet.items[0].cpuOptions),core = toint(parse_json(ResponseElements).instancesSet.items[0].cpuOptions.coreCount),corThread = toint(parse_json(ResponseElements).instancesSet.items[0].cpuOptions.threadsPerCore),InstanceId = tostring(parse_json(ResponseElements).instancesSet.items[0].instanceId)// Filter out instances with empty core values| where isnotempty(core)// Calculate the total compute based on core and thread counts| extend totalCorecompute = core * corThread| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")// Summarize relevant information for analysis| summarize Start= min(TimeGenerated),  end=   max(TimeGenerated),  totalgpu= sum(totalCorecompute)  by SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserAgent// Filter results based on total GPU compute and time duration| where totalgpu > 800| where datetime_diff('hour', end, Start) < 8",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Impact"
            ],
            "tacticsMultiple": "Impact",
            "techniques": [
                "T1496"
            ],
            "techniquesMultiple": "T1496",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "49ce5322-60d7-4b02-ad79-99f650aa5790",
            "displayName": "Privilege escalation with admin managed policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on admin managed policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where  EventName in (\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| where tostring(parse_json(RequestParameters).policyArn) contains \"Admin\" and tostring(parse_json(RequestParameters).policyArn) !contains \"FullAccess\" and tostring(parse_json(RequestParameters).policyArn) !startswith \"arn:aws:iam::aws:policy/AdministratorAccess\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| project TimeGenerated, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, RequestParameters, ResponseElements, UserIdentityArn| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "467cbe7e-e6d4-4f4e-8e44-84dd01932c32",
            "displayName": "Created CRUD S3 policy and then privilege escalation",
            "description": "Detected creation of new CRUD S3 policy and afterwards used one of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Action contains \"s3:Create\" and Action contains \"s3:Get\" and Action contains \"s3:Put\" and Action contains \"s3:Delete\") and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName, UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"SourceIpAddress\", SourceIpAddress, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, AttachEventCount, RecipientAccountId, AccountName, AccountUPNSuffix);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "75647b58-bcc8-4eb5-9658-46698d3fa153",
            "displayName": "SSM document is publicly exposed",
            "description": "Detected a SSM document that is publicly exposed, which could lead to sensitive information leakage to the public. Verify the object configurations.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where  EventName == \"ModifyDocumentPermission\" and isempty(ErrorCode) and isempty(ErrorMessage)| where todynamic(parse_json(RequestParameters).[\"accountIdsToAdd\"]) == '[\"all\"]'| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | project TimeGenerated, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent,UserIdentityUserName, SessionMfaAuthenticated, RecipientAccountId, AccountName, AccountUPNSuffix, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, RequestParameters, ResponseElements, UserIdentityArn| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Discovery"
            ],
            "tacticsMultiple": "Discovery",
            "techniques": [
                "T1526"
            ],
            "techniquesMultiple": "T1526",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "19602494-94af-43c8-90ba-eb0e14999612",
            "displayName": "Automatic image scanning disabled for ECR",
            "description": "Image Scanning for ECR was disabled, which could lead to missing vulnerable container images in your environment. Attackers could disable the Image Scanning for defense evasion purposes.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName == \"PutImageScanningConfiguration\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend scanOnPush = parse_json(tostring((parse_json(RequestParameters).imageScanningConfiguration))).scanOnPush| where scanOnPush == false| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| distinct TimeGenerated, EventName, SourceIpAddress, UserIdentityArn, UserIdentityUserName, RecipientAccountId, AccountName, AccountUPNSuffix| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Defense Evasion"
            ],
            "tacticsMultiple": "Defense Evasion",
            "techniques": [
                "T1562"
            ],
            "techniquesMultiple": "T1562",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "093fe75e-44f1-4d3e-94dc-6d258a6dd2d2",
            "displayName": "AWS Config Service Resource Deletion Attempts",
            "description": "Detects attempts to remove a part of the AWS Config Service.The Threat Actor may manipulate the Config services decrease the visibility into the security posture of an account and / or its workload instances.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Low",
            "query": "let EventNameList = dynamic([\"UpdateTrail\",\"DeleteTrail\",\"StopLogging\",\"DeleteFlowLogs\",\"DeleteEventBus\"]);AWSCloudTrail| where EventName in~ (EventNameList)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent,UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource| extend timestamp = StartTimeUtc",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Defense Evasion"
            ],
            "tacticsMultiple": "Defense Evasion",
            "techniques": [
                "T1562",
                "T1562"
            ],
            "techniquesMultiple": "T15621\ue946T1562",
            "subTechniques": [
                "T1562.001"
            ],
            "subTechniquesMultiple": "T1562.001",
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.0",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "e20d35a3-4fec-4c8b-81b1-fc33b41990b0",
            "displayName": "Privilege escalation via CRUD IAM policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy by CRUD IAM policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail  | where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)  | extend PolicyName = tostring(parse_json(RequestParameters).policyName)  | extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement  | mvexpand Statement  | extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)  | extend Action = tostring(Action)  | where Effect =~ \"Allow\" and (Action contains \"iam:Create\" and (Action contains \"iam:Get\" or Action contains \"iam:List\")  and Action contains \"iam:Update\" and Action contains \"iam:Delete\") and Resource == \"*\" and Condition == \"\"  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)  | extend UserName = tostring(split(UserIdentityArn, '/')[-1])  | extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)  | extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName  | extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "32555639-b639-4c2b-afda-c0ae0abefa55",
            "displayName": "Monitor AWS Credential abuse or hijacking",
            "description": "Looking for GetCallerIdentity Events where the UserID Type is AssumedRoleAn attacker who has assumed the role of a legitimate account can call the GetCallerIdentity function to determine what account they are using.A legitimate user using legitimate credentials would not need to call GetCallerIdentity since they should already know what account they are using.More Information: https://duo.com/decipher/trailblazer-hunts-compromised-credentials-in-awsAWS STS GetCallerIdentity API: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html ",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Low",
            "query": "AWSCloudTrail| where EventName =~ \"GetCallerIdentity\" and UserIdentityType =~ \"AssumedRole\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by SourceIpAddress, EventName, EventTypeName, UserIdentityType, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, UserIdentityPrincipalid,UserAgent, UserIdentityUserName, SessionMfaAuthenticated,AWSRegion, EventSource, AdditionalEventData, ResponseElements| extend timestamp = StartTime| sort by EndTime desc nulls last",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Discovery"
            ],
            "tacticsMultiple": "Discovery",
            "techniques": [
                "T1087"
            ],
            "techniquesMultiple": "T1087",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "139e7116-3884-4246-9978-c8f740770bdf",
            "displayName": "Privilege escalation with AdministratorAccess managed policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on AdministratorAccess managed policy. Attackers could use these events for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where  EventName in (\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| where tostring(parse_json(RequestParameters).policyArn) startswith \"arn:aws:iam::aws:policy/AdministratorAccess\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| project TimeGenerated, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent,UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, RequestParameters, UserIdentityArn, ResponseElements, RecipientAccountId, AccountName, AccountUPNSuffix| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "370f0e5e-da1d-4a14-8ced-d1d7ab66a8d7",
            "displayName": "Privilege escalation via Glue policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on Glue policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail  | where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)  | extend PolicyName = tostring(parse_json(RequestParameters).policyName)  | extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement  | mvexpand Statement  | extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)  | extend Action = tostring(Action)  | where Effect =~ \"Allow\" and ((((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"glue:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"glue:CreateDevEndpoint\" and Action contains \"glue:GetDevEndpoints\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"glue:Create*\" and Action contains \"glue:Get*\")) or (Action contains \"glue:*\") or (Action contains \"glue:GetDevEndpoints\" and Action contains \"glue:UpdateDevEndpoint\") or (Action contains \"glue:Get*\" and Action contains \"glue:Update*\")) and Resource == \"*\" and Condition == \"\"  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)  | extend UserName = tostring(split(UserIdentityArn, '/')[-1])  | extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)  | extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName  | extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "efdc3cff-f006-426f-97fd-4657862f7b9a",
            "displayName": "CloudFormation policy created then used for privilege escalation",
            "description": "Detected creation of new Cloudformation policy and usage of one of the attach policy events (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (((Action has \"iam:*\" or Action has \"iam:PassRole\") and Action has \"cloudformation:*\") or ((Action has \"iam:*\" or Action has \"iam:PassRole\") and Action contains \"cloudformation:DescribeStacks\" and Action contains \"cloudformation:CreateStack\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"cloudformation:Describe*\" and Action contains \"cloudformation:Create*\")) and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn,  RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityType , UserIdentityArn, SourceIpAddress, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"SourceIpAddress\", SourceIpAddress, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, AttachEventCount, RecipientAccountId, AccountName, AccountUPNSuffix);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "48896551-1c28-4a09-8388-e51e5a927d23",
            "displayName": "Privilege escalation via DataPipeline policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on Datapipeline policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail  | where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)  | extend PolicyName = tostring(parse_json(RequestParameters).policyName)  | extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement  | mvexpand Statement  | extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)  | extend Action = tostring(Action)  | where Effect =~ \"Allow\" and (((Action has \"iam:*\" or Action has \"iam:PassRole\") and Action has \"datapipeline:*\") or ((Action has \"iam:*\" or Action has \"iam:PassRole\") and Action has \"datapipeline:CreatePipeline\" and Action has \"datapipeline:PutPipelineDefinition\" and Action has \"datapipeline:ActivatePipeline\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"datapipeline:Create*\" and Action contains \"datapipeline:Put*\" and Action contains \"datapipeline:Activate*\")) and Resource == \"*\" and isempty(Condition)  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)  | extend UserName = tostring(split(UserIdentityArn, '/')[-1])  | extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)  | extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName  | extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "8e15998e-1e32-4b6d-abd1-e8482e8f3def",
            "displayName": "Creation of CRUD KMS policy and then privilege escalation",
            "description": "Detected creation of new CRUD KMS policy and usage of one of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Action contains \"kms:Create\" and (Action contains \"kms:Get\" or Action contains \"kms:Describe\")  and (Action contains \"kms:Disable\" or Action contains \"kms:Enable\") and Action contains \"kms:Delete\") and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn,  RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"SourceIpAddress\", SourceIpAddress, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, RecipientAccountId, AccountName, AccountUPNSuffix, AttachEventCount);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "8c2ef238-67a0-497d-b1dd-5c8a0f533e25",
            "displayName": "Changes to internet facing AWS RDS Database instances",
            "description": "Amazon Relational Database Service (RDS) is scalable relational database in the cloud.If your organization have one or more AWS RDS Databases running, monitoring changes to especially internet facing AWS RDS (Relational Database Service)Once alerts triggered, validate if changes observed are authorized and adhere to change control policy.More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255and RDS API Reference Docs: https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Operations.html",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Low",
            "query": "let EventNameList = dynamic([\"AuthorizeDBSecurityGroupIngress\",\"CreateDBSecurityGroup\",\"DeleteDBSecurityGroup\",\"RevokeDBSecurityGroupIngress\"]);AWSCloudTrail| where EventName in~ (EventNameList)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements| extend timestamp = StartTimeUtc",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Persistence"
            ],
            "tacticsMultiple": "Persistence",
            "techniques": [
                "T1098"
            ],
            "techniquesMultiple": "T1098",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "aaa2c05e-fdd4-4fa0-9072-6cffe3641b34",
            "displayName": "Creation of SSM policy and then privilege escalation",
            "description": "Detected creation of new SSM policy and afterwards used one of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);  let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Action contains \"ssm:*\" or Action contains \"ssm:Create*\" or Action contains \"ssm:CreateAssociation\") and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn, \"SourceIpAddress\", SourceIpAddress)| project EventSource, PolicyName, AttachEvent, RecipientAccountId, AccountName, AccountUPNSuffix, AttachEventCount);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "09f2a28b-3286-4268-9e2f-33805f104e5d",
            "displayName": "S3 object publicly exposed",
            "description": "Detected S3 bucket that's publicly exposed, which could lead to sensitive information leakage to the public. Verify the S3 object configurations.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail  | where EventName == \"PutObjectAcl\" and isempty(ErrorCode) and isempty(ErrorMessage)  | extend Grant = parse_json(tostring((parse_json(RequestParameters).AccessControlPolicy))).AccessControlList.Grant  | mvexpand Grant  | extend cannedacl = parse_json(tostring((parse_json(RequestParameters))))  | extend URI = parse_json(Grant).Grantee.URI, type = parse_json(Grant).Grantee.[\"xsi:type\"], xamzacl = parse_json(cannedacl).[\"x-amz-acl\"]  | where (type == \"Group\" and (URI endswith \"AllUsers\" or URI endswith \"AuthenticatedUsers\"))    or xamzacl in (\"authenticated-read\",\"public-read\",\"public-read-write\")  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)  | extend UserName = tostring(split(UserIdentityArn, '/')[-1])  | extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)  | extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | extend timestamp = TimeGenerated",
            "ruleFrequency": "1 hour",
            "rulePeriod": "1 hour",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Exfiltration"
            ],
            "tacticsMultiple": "Exfiltration",
            "techniques": [
                "T1537"
            ],
            "techniquesMultiple": "T1537",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "bce1dcba-4948-414d-8838-6385afb9d496",
            "displayName": "SAML update identity provider",
            "description": "Attackers could update the SAML provider in order to create unauthorized but valid tokens and represent them to services that trust SAML tokens from the environment. These tokens can then be used to access resources. More about this API at https://docs.aws.amazon.com/IAM/latest/APIReference/API_UpdateSAMLProvider.html ",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "AWSCloudTrail| where EventName == \"UpdateSAMLProvider\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Persistence"
            ],
            "tacticsMultiple": "Persistence",
            "techniques": [
                "T1078"
            ],
            "techniquesMultiple": "T1078",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "56626956-304f-4408-8ea6-7ba5746ce09e",
            "displayName": "Creation of Glue policy and then privilege escalation",
            "description": "Detected creation of new Glue policy and usage one of the attach policy operations (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and ((((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"glue:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"glue:CreateDevEndpoint\" and Action contains \"glue:GetDevEndpoints\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"glue:Create*\" and Action contains \"glue:Get*\")) or (Action contains \"glue:*\") or (Action contains \"glue:GetDevEndpoints\" and Action contains \"glue:UpdateDevEndpoint\") or (Action contains \"glue:Get*\" and Action contains \"glue:Update*\")) and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType,\"SourceIpAddress\", SourceIpAddress, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, RecipientAccountId, AccountName, AccountUPNSuffix, AttachEventCount);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "bf0cde21-0c41-48f6-a40c-6b5bd71fa106",
            "displayName": "AWS Guard Duty Alert",
            "description": "Amazon GuardDuty is a threat detection service that continuously monitors your AWS accounts and workloads for malicious activity and delivers detailed security findings for visibility and remediation. This templates create an alert for each Amazon GuardDuty finding.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "// https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_findings.html AWSGuardDuty // Parse the finding// https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-format.html // Example: \"ThreatPurpose:ResourceTypeAffected/ThreatFamilyName.DetectionMechanism!Artifact\"| extend findingTokens = split(ActivityType, \":\")| extend ThreatPurpose=findingTokens[0], findingTokens=split(findingTokens[1], \"/\")| extend ResourceTypeAffected=findingTokens[0], findingTokens= split(findingTokens[1], \".\")| extend ThreatFamilyName=findingTokens[0], findingTokens=split(findingTokens[1], \"!\")| extend DetectionMechanism=findingTokens[0], Artifact=findingTokens[1]// Assign severity level// https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_findings.html#guardduty_findings-severity| extend Severity =     case (      Severity >= 7.0, \"High\",      Severity between (4.0 .. 6.9), \"Medium\",      Severity between (1.0 .. 3.9), \"Low\",      \"Unknown\"    )// Pull out any available resource details we can extract entities from. These may not exist in the alert.// https://docs.aws.amazon.com/guardduty/latest/APIReference/API_Resource.html // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_AccessKeyDetails.html // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_RdsDbUserDetails.html // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_KubernetesDetails.html | extend AccessKeyDetails=ResourceDetails.accessKeyDetails| extend RdsDbUserDetails=ResourceDetails.rdsDbUserDetails| extend KubernetesDetails=ResourceDetails.kubernetesDetails// Pull out any available action details we can extract entities from. These may not exist in the alert.// https://docs.aws.amazon.com/guardduty/latest/APIReference/API_Action.html // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_AwsApiCallAction.html // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_KubernetesApiCallAction.html // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_NetworkConnectionAction.html // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_RdsLoginAttemptAction.html | extend ServiceAction =     case(      isnotempty(ServiceDetails.action.awsApiCallAction), ServiceDetails.action.awsApiCallAction,      isnotempty(ServiceDetails.action.kubernetesApiCallAction), ServiceDetails.action.kubernetesApiCallAction,      isnotempty(ServiceDetails.action.networkConnectionAction), ServiceDetails.action.networkConnectionAction,      isnotempty(ServiceDetails.action.rdsLoginAttemptAction), ServiceDetails.action.rdsLoginAttemptAction,      dynamic(null)    )// The IPv4 remote address of the connection// https://docs.aws.amazon.com/guardduty/latest/APIReference/API_RemoteIpDetails.html // or// The IP of the Kubernetes API caller and the IPs of any proxies or load balancers between the caller and the API endpoint // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_KubernetesApiCallAction.html | extend RemoteIpAddress =     coalesce(      tostring(ServiceAction.remoteIpDetails.ipAddressV4),      tostring(parse_json(ServiceAction.sourceIPs)[0])    )// The IPv4 local address of the connection// https://docs.aws.amazon.com/guardduty/latest/APIReference/API_LocalIpDetails.html | extend LocalIpAddress = ServiceAction.localIpDetails.ipAddressV4// The AWS account ID of the remote API caller.// https://docs.aws.amazon.com/guardduty/latest/APIReference/API_AwsApiCallAction.html // https://docs.aws.amazon.com/guardduty/latest/APIReference/API_RemoteAccountDetails.html | extend RemoteAWSAccountId = ServiceAction.remoteAccountDetails.accountId// The IAM access key details (user information) of a user that engaged in the activity that prompted GuardDuty to generate a finding// https://docs.aws.amazon.com/guardduty/latest/APIReference/API_AccessKeyDetails.html | extend AccountUpn =     case(      AccessKeyDetails.userType == \"IAMUser\", AccessKeyDetails.userName,      AccessKeyDetails.userType == \"AssumedRole\", split(AccessKeyDetails.principalId, \":\", 1)[0],      isnotempty(RdsDbUserDetails.user), RdsDbUserDetails.user,      isnotempty(KubernetesDetails.kubernetesUserDetails.username), KubernetesDetails.kubernetesUserDetails.username,      \"\"    )| extend AccountName = split(AccountUpn, \"@\", 0)[0]| extend UPNSuffix = split(AccountUpn, \"@\", 1)[0]// Clean up the output| extend GuardDutyDetails =    bag_pack(       \"DetectorId\", ServiceDetails.detectorId,      \"Partition\", Partition,      \"Region\", Region    )| extend FindingLink =     iff(      isnotempty(Region) and isnotempty(Id),      strcat(\"https://\", Region, \".console.aws.amazon.com/guardduty/home?region=\", Region, \"#/findings?fId=\", Id),      \"\"    )| extend FindingLinkDescription =     iff(      isnotempty(FindingLink),      strcat(\"Link to GuardDuty finding (AWS): \", FindingLink),      \"\"    )| project-rename     FindingArn=Arn,    FindingId=Id,    AWSAccountId=AccountId| project-away     ActivityType,     findingTokens,    Partition,    Region,     SchemaVersion,    TimeGenerated,    Type",
            "ruleFrequency": "5 hours",
            "rulePeriod": "5 hours",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [],
            "tacticsMultiple": [],
            "techniques": [],
            "techniquesMultiple": [],
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "UPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RemoteAWSAccountId",
                            "identifier": "ObjectGuid"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "RemoteIpAddress",
                            "identifier": "Address"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "LocalIpAddress",
                            "identifier": "Address"
                        }
                    ]
                },
                {
                    "entityType": "URL",
                    "fieldMappings": [
                        {
                            "columnName": "FindingLink",
                            "identifier": "Url"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWSS3",
            "dataConnectorName": "Amazon Web Services S3",
            "dataTypes": "AWSGuardDuty --",
            "version": "1.0.6",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "b442b9e2-5cc4-4129-a85b-a5ef38a9e5f0",
            "displayName": "S3 bucket suspicious ransomware activity",
            "description": "Suspicious S3 bucket activity indicating ransomware was detected.An attacker might download all the objects in a compromised S3 bucket, encrypt them with his own key, then upload them back to the same bucket, overwriting the existing ones.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let timeframe = 1h;let lookback = 2h;// The attacker downloads the object(s) from the compromised bucketlet GetObject = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName == \"GetObject\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend bucketName = tostring(parse_json(RequestParameters).bucketName), keyName = tostring(parse_json(RequestParameters).key)| project-rename StartTime = TimeGenerated;// Then, the attacker overwrites the same object(s) but encrypted with his own keylet PutObject = AWSCloudTrail| where TimeGenerated >= ago(timeframe)| where EventName == \"PutObject\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend bucketName = tostring(parse_json(RequestParameters).bucketName), keyName = tostring(parse_json(RequestParameters).key)| extend kmsId = tostring(parse_json(RequestParameters).[\"x-amz-server-side-encryption-aws-kms-key-id\"])| where tostring(kmsId) !has tostring(RecipientAccountId) and kmsId <> \"\";PutObject| join kind=inner (   GetObject)on $left.bucketName == $right.bucketName, $left.keyName == $right.keyName| where TimeGenerated > StartTime| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = StartTime",
            "ruleFrequency": "1 hour",
            "rulePeriod": "1 hour",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Impact"
            ],
            "tacticsMultiple": "Impact",
            "techniques": [
                "T1486"
            ],
            "techniquesMultiple": "T1486",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "610d3850-c26f-4f20-8d86-f10fdf2425f5",
            "displayName": "Changes made to AWS CloudTrail logs",
            "description": "Attackers often try to hide their steps by deleting or stopping the collection of logs that could show their activity.This alert identifies any manipulation of AWS CloudTrail, Cloudwatch/EventBridge or VPC Flow logs.More Information: AWS CloudTrail API: https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_Operations.htmlAWS Cloudwatch/Eventbridge API: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_Operations.htmlAWS DelteteFlowLogs API : https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteFlowLogs.html ",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Low",
            "query": "let EventNameList = dynamic([\"UpdateTrail\",\"DeleteTrail\",\"StopLogging\",\"DeleteFlowLogs\",\"DeleteEventBus\"]);AWSCloudTrail| where EventName in~ (EventNameList)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent,UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource| extend timestamp = StartTimeUtc",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Defense Evasion"
            ],
            "tacticsMultiple": "Defense Evasion",
            "techniques": [
                "T1070"
            ],
            "techniquesMultiple": "T1070",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.4",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "0ee2aafb-4500-4e36-bcb1-e90eec2f0b9b",
            "displayName": "NRT Login to AWS Management Console without MFA",
            "description": "Multi-Factor Authentication (MFA) helps you to prevent credential compromise. This alert identifies logins to the AWS Management Console without MFA.You can limit this detection to trigger for administrative accounts if you do not have MFA enabled on all accounts.This is done by looking at the eventName ConsoleLogin and if the AdditionalEventData field indicates MFA was NOT used and the ResponseElements field indicates NOT a Failure. Thereby indicating that a non-MFA login was successful.",
            "kind": "AnalyticsRule",
            "ruleType": "NRT",
            "severity": "Low",
            "query": "AWSCloudTrail| where EventName =~ \"ConsoleLogin\"| extend MFAUsed = tostring(parse_json(AdditionalEventData).MFAUsed), LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin)| where MFAUsed !~ \"Yes\" and LoginResult !~ \"Failure\"| where SessionIssuerUserName !contains \"AWSReservedSSO\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, LoginResult, MFAUsed, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId,  UserIdentityPrincipalid, UserAgent,  UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion",
            "ruleFrequency": "",
            "rulePeriod": "",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "",
            "tactics": [
                "Defense Evasion",
                "Privilege Escalation",
                "Persistence",
                "Initial Access"
            ],
            "tacticsMultiple": "Defense Evasion3\ue946Privilege EscalationPersistenceInitial Access",
            "techniques": [
                "T1078"
            ],
            "techniquesMultiple": "T1078",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "874a1762-3fd7-4489-b411-6d4a9e9e8a59",
            "displayName": "Policy version set to default",
            "description": "An attacker with SetDefaultPolicyVersion permissions could escalate privileges through existing policy versions that are not currently in use. More about this API at https://docs.aws.amazon.com/IAM/latest/APIReference/API_SetDefaultPolicyVersion.html ",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName == \"SetDefaultPolicyVersion\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 hour",
            "rulePeriod": "1 hour",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Initial Access"
            ],
            "tacticsMultiple": "Initial Access",
            "techniques": [
                "T1078"
            ],
            "techniquesMultiple": "T1078",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "22115d3c-e87c-485a-9130-33797d619124",
            "displayName": "Creation of CRUD Lambda policy and then privilege escalation",
            "description": "Detected creation of new CRUD Lambda policy and usage of the attach policy events (AttachUserPolicy/AttachRolePolicy/AttachGroupPolicy). This might indicate a privilege escalation technique that attackers could use.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);let createPolicy =  dynamic([\"CreatePolicy\", \"CreatePolicyVersion\"]);let timeframe = 1d;let lookback = 14d;// Creating Master table with all the events to use with materialize for better performancelet EventInfo = AWSCloudTrail| where TimeGenerated >= ago(lookback)| where EventName in (EventNameList) or EventName in (createPolicy)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\");//Checking for Policy creation event with Full Admin Privileges since lookback period.let FullAdminPolicyEvents =  materialize(  EventInfo| where TimeGenerated >= ago(lookback)| where EventName in (createPolicy)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Action contains \"lambda:Create\" and Action contains \"lambda:Get\" and Action contains \"lambda:Update\" and Action contains \"kms:Delete\") and Resource == \"*\" and Condition == \"\"| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, RecipientAccountId, AccountName, AccountUPNSuffix| project-rename StartTime = TimeGenerated  );let PolicyAttach = materialize(  EventInfo| where TimeGenerated >= ago(timeframe)| where EventName in (EventNameList) and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName, UserIdentityType , UserIdentityArn, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, PolicyName| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"SourceIpAddress\", SourceIpAddress, \"AccountName\", AccountName, \"AccountUPNSuffix\", AccountUPNSuffix, \"RecipientAccountId\", RecipientAccountId, \"UserIdentityArn\", UserIdentityArn)| project EventSource, PolicyName, AttachEvent, RecipientAccountId, AccountName, AccountUPNSuffix, AttachEventCount);// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.FullAdminPolicyEvents| join kind=leftouter(    PolicyAttach)on PolicyName| project-away PolicyName1| extend timestamp = StartTime",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.3",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "c668c09f-5a49-43f9-b249-6b89a31ec8fb",
            "displayName": "Privilege escalation via SSM policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on SSM Policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail  | where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)  | extend PolicyName = tostring(parse_json(RequestParameters).policyName)  | extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement  | mvexpand Statement  | extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)  | extend Action = tostring(Action)  | where Effect =~ \"Allow\" and (Action contains \"ssm:*\" or Action contains \"ssm:Create*\" or Action contains \"ssm:CreateAssociation\") and Resource == \"*\" and isempty(Condition)  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)  | extend UserName = tostring(split(UserIdentityArn, '/')[-1])  | extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)  | extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName  | extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "60dfc193-0f73-4279-b43c-110ade02b201",
            "displayName": "Suspicious overly permissive KMS key policy created",
            "description": "An overly permissive key policy was created, resulting in KMS keys where the kms:Encrypt action is accessible to everyone (even outside of the organization). This could mean that your account is compromised and that the attacker is using the encryption key to compromise other organizations.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let kmsActions = dynamic([\"kms:Encrypt\", \"kms:*\"]); //Add other overly permissive APIs to this list.AWSCloudTrail| where EventName in (\"CreateKey\",\"PutKeyPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policy))).Statement| mvexpand Statement| extend Action = tostring(parse_json(Statement).Action), Effect = tostring(parse_json(Statement).Effect), Principal = iff(isnotempty(tostring(parse_json(Statement).Principal.AWS)),tostring(parse_json(Statement).Principal.AWS), tostring(parse_json(Statement).Principal))| where Effect =~ \"Allow\" and Action has_any (kmsActions) and Principal == \"*\" | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Impact"
            ],
            "tacticsMultiple": "Impact",
            "techniques": [
                "T1486"
            ],
            "techniquesMultiple": "T1486",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.4",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "0adab960-5565-4978-ba6d-044553e4acc4",
            "displayName": "Successful API executed from a Tor exit node",
            "description": "A successful API execution was detected from an IP address categorized as a TOR exit node by Threat Intelligence.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let TorNodes = (externaldata (TorIP:string)[h@'https://firewalliplists.gypthecat.com/lists/kusto/kusto-tor-exit.csv.zip']with (ignoreFirstRecord=true));AWSCloudTrail| where SourceIpAddress in (TorNodes) and isempty(ErrorCode) and isempty(ErrorMessage)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Execution"
            ],
            "tacticsMultiple": "Execution",
            "techniques": [
                "T1204"
            ],
            "techniquesMultiple": "T1204",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "a2b2a984-c820-4d93-830e-139bffd81fa3",
            "displayName": "Privilege escalation via EC2 policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on EC2 policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail  | where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)  | extend PolicyName = tostring(parse_json(RequestParameters).policyName)  | extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement  | mvexpand Statement  | extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)  | extend Action = tostring(Action)  | where Effect =~ \"Allow\" and ((((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"ec2:*\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"ec2:RunInstances\") or ((Action contains \"iam:*\" or Action contains \"iam:PassRole\") and Action contains \"ec2:Run*\")) or (Action contains \"ec2:*\") or (Action contains \"ec2:ListInstances\" and Action contains \"ec2:StartInstance\" and Action contains \"ec2:ModifyInstanceAttribute\") or (Action contains \"ec2:List*\" and Action contains \"ec2:Start*\" and Action contains \"ec2:Modify*\")) and Resource == \"*\" and Condition == \"\"  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)  | extend UserName = tostring(split(UserIdentityArn, '/')[-1])  | extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)  | extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),    AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")  | distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, UserIdentityUserName, RecipientAccountId, AccountName, AccountUPNSuffix  | extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "f6928301-56da-4d2c-aabe-e1a552bc8892",
            "displayName": "ECR image scan findings high or critical",
            "description": "AWS ECR Image scan detected critical or high-severity vulnerabilities in your container image.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "AWSCloudTrail| where EventName == \"DescribeImageScanFindings\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend repoName = tostring(parse_json(ResponseElements).repositoryName)| extend imageId = tostring(parse_json(ResponseElements).imageId.imageDigest)| extend Critical = toint(parse_json(ResponseElements).imageScanFindings.findingSeverityCounts.CRITICAL)| extend High = toint(parse_json(ResponseElements).imageScanFindings.findingSeverityCounts.HIGH)| where Critical > 0 or High > 0| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Execution"
            ],
            "tacticsMultiple": "Execution",
            "techniques": [
                "T1204"
            ],
            "techniquesMultiple": "T1204",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "fc3061bb-319c-4fe9-abe2-f59899a6d907",
            "displayName": "Privilege escalation via CRUD S3 policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy by CRUD S3 Policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName in (\"PutUserPolicy\",\"PutRolePolicy\",\"PutGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| extend PolicyName = tostring(parse_json(RequestParameters).policyName)| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Action contains \"s3:Create\" and Action contains \"s3:Get\" and Action contains \"s3:Put\" and Action contains \"s3:Delete\") and Resource == \"*\" and Condition == \"\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "afb4191b-a142-4065-a0da-f721ee3d006c",
            "displayName": "Privilege escalation with FullAccess managed policy",
            "description": "Detected usage of AttachUserPolicy/AttachGroupPolicy/AttachRolePolicy on FullAccess managed policy. Attackers could use these operations for privilege escalation. Verify these actions with the user.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where  EventName in (\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\") and isempty(ErrorCode) and isempty(ErrorMessage)| where tostring(parse_json(RequestParameters).policyArn) has \"FullAccess\" and tostring(parse_json(RequestParameters).policyArn) !has \"Admin\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| project TimeGenerated, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, RequestParameters, UserIdentityArn, ResponseElements| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Privilege Escalation"
            ],
            "tacticsMultiple": "Privilege Escalation",
            "techniques": [
                "T1484"
            ],
            "techniquesMultiple": "T1484",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "8c2dc344-9352-4ca1-8863-b1b7a5e09e59",
            "displayName": "Suspicious AWS CLI Command Execution",
            "description": "This detection focuses on identifying potentially suspicious activities involving the execution of AWS Command Line Interface (CLI) commands, particularly focusing on reconnaissance operations.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "let SuspiciousCommands= pack_array('iam.list-users', 'iam.list-groups', 'ec2.describe-vpcs', 'ec2.describe-subnets', 'route53.list-hosted-zones', 'kms.list-keys', 'kms.list-aliases', 'ecs.list-clusters', 'ecs.list-services', 'iam.list-roles', 'iam.get-user''iam.list-access-keys', 'ec2.describe-security-groups', 'ec2.describe-network-acls', 'ec2.describe-network-interfaces', 'ec2.describe-route-tables', 'ec2.describe-internet-gateways', 'ec2.describe-vpc-peering-connections', 'ec2.describe-network-interfaces', 'ec2.describe-network-interfaces', 'ec2.describe-transit-gateway-vpc-attachment', 'ec2.describe-vpc');// Retrieve AWS CloudTrail eventsAWSCloudTrail // Filter events with UserAgent starting with \"aws-cli\"| where UserAgent startswith \"aws-cli\" // Extract the command from the UserAgent using string splitting| extend command = tostring(split(UserAgent, \"off command/\", 1)[0])  // Filter events based on predefined suspicious command list| where command has_any (SuspiciousCommands)  | extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")// Summarize relevant information for further analysis| summarize     CommadCount = dcount(command),     EventCount = dcount(EventName),     commands = make_list(command),     Events = make_list(EventName)     by     bin(TimeGenerated, 1min),     RecipientAccountId, AccountName, AccountUPNSuffix,     UserIdentityUserName,     SourceIpAddress,     SessionMfaAuthenticated // Filter out results with a sufficient count of unique suspicious commands in 1 min time window| where CommadCount >= 8",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Reconnaissance"
            ],
            "tacticsMultiple": "Reconnaissance",
            "techniques": [
                "T1595",
                "T1592",
                "T1589",
                "T1589",
                "T1590",
                "T1591",
                "T1596"
            ],
            "techniquesMultiple": "T15956\ue946T1592T1589T1589T1590T1591T1596",
            "subTechniques": [
                "T1592.004",
                "T1589.002",
                "T1589.003"
            ],
            "subTechniquesMultiple": "T1592.0042\ue946T1589.002T1589.003",
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "21702832-aff3-4bd6-a8e1-663b6818503d",
            "displayName": "Suspicious command sent to EC2",
            "description": "An attacker with the necessary permissions could be executing code remotely on a machine and saving the output to his own S3 bucket. Verify this action with the user identity.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let command_executed = AWSCloudTrail| where EventName in (\"SendCommand\",\"CreateAssociation\") and isempty(ErrorCode) and isempty(ErrorMessage)| extend params = tostring(parse_json(RequestParameters).parameters)| extend s3bucketCommand = tostring(parse_json(RequestParameters).outputS3BucketName)| extend s3bucketAssociation = tostring(parse_json(RequestParameters).outputLocation.s3Location.outputS3BucketName)| where isnotempty(params)| extend commandId = tostring(parse_json(ResponseElements).command.commandId)| extend associationId = tostring(parse_json(ResponseElements).associationDescription.associationId)| extend executionId = iff(isnotempty(commandId), commandId, associationId)| extend s3bucket = iff(isnotempty(s3bucketCommand), s3bucketCommand, s3bucketAssociation)| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))| extend timestamp = TimeGenerated;AWSCloudTrail| where EventName == \"PutObject\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend s3bucket = tostring(parse_json(RequestParameters).bucketName)| mv-expand todynamic(Resources)| extend accountId=tostring(todynamic(Resources.['accountId']))| where Resources contains \"accountId\" and accountId <> RecipientAccountId| join command_executed on s3bucket| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Execution"
            ],
            "tacticsMultiple": "Execution",
            "techniques": [
                "T1204"
            ],
            "techniquesMultiple": "T1204",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "633a91df-d031-4b6e-a413-607a61540559",
            "displayName": "Tampering to AWS CloudTrail logs",
            "description": "Attackers often try to hide their steps by deleting or stopping the collection of logs that could show their activity.This alert identifies any manipulation of AWS CloudTrail, Cloudwatch/EventBridge or VPC Flow logs.More Information: AWS CloudTrail API: https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_Operations.htmlAWS Cloudwatch/Eventbridge API: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_Operations.htmlAWS DelteteFlowLogs API : https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteFlowLogs.html ",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let EventNameList = dynamic([\"UpdateTrail\",\"DeleteTrail\",\"StopLogging\",\"DeleteFlowLogs\",\"DeleteEventBus\",\"DeleteLogGroup\"]);AWSCloudTrail| where (EventName in~ (EventNameList) or (EventName == \"UpdateTrail\" and (parse_json(RequestParameters).enableLogFileValidation) == false) or (EventName == \"UpdateTrail\" and (parse_json(RequestParameters).isMultiRegionTrail) == false)) and isempty(ErrorMessage) and isempty(ErrorCode)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName), AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource| extend timestamp = StartTimeUtc",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Defense Evasion"
            ],
            "tacticsMultiple": "Defense Evasion",
            "techniques": [
                "T1070"
            ],
            "techniquesMultiple": "T1070",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.4",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "d25b1998-a592-4bc5-8a3a-92b39eedb1bc",
            "displayName": "Login to AWS Management Console without MFA",
            "description": "Multi-Factor Authentication (MFA) helps you to prevent credential compromise. This alert identifies logins to the AWS Management Console without MFA.You can limit this detection to trigger for adminsitrative accounts if you do not have MFA enabled on all accounts.This is done by looking at the eventName ConsoleLogin and if the AdditionalEventData field indicates MFA was NOT used and the ResponseElements field indicates NOT a Failure. Thereby indicating that a non-MFA login was successful.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Low",
            "query": "AWSCloudTrail| where EventName =~ \"ConsoleLogin\"| extend MFAUsed = tostring(parse_json(AdditionalEventData).MFAUsed), LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin), indexId = indexof(tostring(UserIdentityPrincipalid),\":\")| where MFAUsed !~ \"Yes\" and LoginResult !~ \"Failure\"| where SessionIssuerUserName !contains \"AWSReservedSSO\"| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, LoginResult, MFAUsed, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId,  UserIdentityPrincipalid, UserAgent,UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, indexId| extend timestamp = StartTimeUtc",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Defense Evasion",
                "Privilege Escalation",
                "Persistence",
                "Initial Access"
            ],
            "tacticsMultiple": "Defense Evasion3\ue946Privilege EscalationPersistenceInitial Access",
            "techniques": [
                "T1078"
            ],
            "techniquesMultiple": "T1078",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.5",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "31b9e94b-0df6-4a3d-a297-3457b53c5d86",
            "displayName": "Successful brute force attack on S3 Bucket.",
            "description": "A successful brute force attack on an S3 bucket was detected. Verify these actions, and if needed, remediate the compromise.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "let timeframe = 1h;let failed_attempts = AWSCloudTrail| where TimeGenerated >= ago(timeframe)| where EventName == \"GetObject\" and isnotempty(ErrorMessage) and isnotempty(ErrorCode)| where UserIdentityAccountId == \"ANONYMOUS_PRINCIPAL\" or UserIdentityAccessKeyId <> RecipientAccountId| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend bucketName = tostring(parse_json(RequestParameters).bucketName), keyName = tostring(parse_json(RequestParameters).key)| summarize time_min_failed=arg_min(TimeGenerated, *), failed_keys = dcount(keyName) by RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, SourceIpAddress, bucketName| where failed_keys > 20;let success_attempts = AWSCloudTrail| where TimeGenerated >= ago(timeframe)| where EventName == \"GetObject\" and isempty(ErrorMessage) and isempty(ErrorCode)| where UserIdentityAccountId == \"ANONYMOUS_PRINCIPAL\" or UserIdentityAccessKeyId <> RecipientAccountId| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend bucketName = tostring(parse_json(RequestParameters).bucketName), keyName = tostring(parse_json(RequestParameters).key)| summarize time_min_success=arg_min(TimeGenerated, *), success_keys = dcount(keyName) by RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, SourceIpAddress, bucketName| where success_keys >= 1;failed_attempts| join kind=inner success_attempts on SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityAccountId, bucketName| where time_min_success > time_min_failed| project-away keyName| extend timestamp = time_min_success",
            "ruleFrequency": "1 hour",
            "rulePeriod": "1 hour",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Defense Evasion"
            ],
            "tacticsMultiple": "Defense Evasion",
            "techniques": [
                "T1562"
            ],
            "techniquesMultiple": "T1562",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "f8ea7d50-e33b-4b9d-9c3e-a59fcbcee281",
            "displayName": "Network ACL with all the open ports to a specified CIDR",
            "description": "Detected network ACL with all the ports open to a specified CIDR. This could lead to potential lateral movements or initial access attacks. Make sure to mitigate this risk.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "High",
            "query": "AWSCloudTrail| where EventName in ('CreateNetworkAclEntry', 'ReplaceNetworkAclEntry') and isempty(ErrorMessage) and isempty(ErrorCode)| extend ruleAction = tostring(parse_json(RequestParameters)['ruleAction']),         egress=parse_json(RequestParameters)['egress'],         total_ports=(toint(parse_json(parse_json(RequestParameters)['portRange'])['to']) - toint(parse_json(parse_json(RequestParameters)['portRange'])['from'])),         aclProtocol=parse_json(RequestParameters)['aclProtocol']| where isnotempty(total_ports)| where ruleAction == 'allow' and egress == false and (aclProtocol == '-1' or (total_ports > 1024))| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 day",
            "rulePeriod": "1 day",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Defense Evasion"
            ],
            "tacticsMultiple": "Defense Evasion",
            "techniques": [
                "T1562"
            ],
            "techniquesMultiple": "T1562",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.2",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "44a5b65e-b0a9-4591-aabc-388fd92a28c4",
            "displayName": "S3 bucket exposed via policy",
            "description": "Detected S3 bucket publicly exposed via policy, this could lead for sensitive information leakage to the public. Verify the S3 object configurations.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName == \"PutBucketPolicy\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend Statement = parse_json(tostring((parse_json(RequestParameters).bucketPolicy))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition), Principal_aws = tostring(parse_json(Statement).Principal.AWS), Principal = tostring(parse_json(Statement).Principal)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Principal_aws == \"*\" or Principal == \"*\") and isempty(Condition)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| distinct TimeGenerated, EventName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 hour",
            "rulePeriod": "1 hour",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Exfiltration"
            ],
            "tacticsMultiple": "Exfiltration",
            "techniques": [
                "T1537"
            ],
            "techniquesMultiple": "T1537",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        },
        {
            "searchKey": "b7a44e0d-ae4c-4fb2-be1b-aa0e45f2327b",
            "displayName": "S3 bucket access point publicly exposed",
            "description": "Detected S3 bucket publicly exposed via access point, which could lead to sensitive information leakage to the public. Verify the S3 object configurations.",
            "kind": "AnalyticsRule",
            "ruleType": "Scheduled",
            "severity": "Medium",
            "query": "AWSCloudTrail| where EventName == \"PutAccessPointPolicy\" and isempty(ErrorCode) and isempty(ErrorMessage)| extend Statement = parse_json(tostring((parse_json(RequestParameters).PutAccessPointPolicyRequest.Policy))).Statement| mvexpand Statement| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource), Condition = tostring(parse_json(Statement).Condition), Principal_aws = tostring(parse_json(Statement).Principal.AWS), Principal = tostring(parse_json(Statement).Principal)| extend Action = tostring(Action)| where Effect =~ \"Allow\" and (Principal_aws == \"*\" or Principal == \"*\") and isempty(Condition)| extend UserIdentityArn = iif(isempty(UserIdentityArn), tostring(parse_json(Resources)[0].ARN), UserIdentityArn)| extend UserName = tostring(split(UserIdentityArn, '/')[-1])| extend AccountName = case( UserIdentityPrincipalid == \"Anonymous\", \"Anonymous\", isempty(UserIdentityUserName), UserName, UserIdentityUserName)| extend AccountName = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 0)[0]), AccountName),  AccountUPNSuffix = iif(AccountName contains \"@\", tostring(split(AccountName, '@', 1)[0]), \"\")| distinct TimeGenerated, EventName, SourceIpAddress, RecipientAccountId, AccountName, AccountUPNSuffix, UserIdentityArn, UserIdentityUserName| extend timestamp = TimeGenerated",
            "ruleFrequency": "1 hour",
            "rulePeriod": "1 hour",
            "suppressionDuration": "1 hour",
            "thresholdTrigger": "more than 0",
            "tactics": [
                "Exfiltration"
            ],
            "tacticsMultiple": "Exfiltration",
            "techniques": [
                "T1537"
            ],
            "techniquesMultiple": "T1537",
            "subTechniques": [],
            "subTechniquesMultiple": [],
            "entityMapping": [
                {
                    "entityType": "Account",
                    "fieldMappings": [
                        {
                            "columnName": "AccountName",
                            "identifier": "Name"
                        },
                        {
                            "columnName": "AccountUPNSuffix",
                            "identifier": "UPNSuffix"
                        },
                        {
                            "columnName": "RecipientAccountId",
                            "identifier": "CloudAppAccountId"
                        }
                    ]
                },
                {
                    "entityType": "IP",
                    "fieldMappings": [
                        {
                            "columnName": "SourceIpAddress",
                            "identifier": "Address"
                        }
                    ]
                }
            ],
            "dataConnectorId": "AWS",
            "dataConnectorName": "Amazon Web Services",
            "dataTypes": "AWSCloudTrail --",
            "version": "1.0.1",
            "source": "Amazon Web Services",
            "author": "Microsoft",
            "support": "Microsoft Corporation",
            "solutionSearchName": "Amazon Web Services"
        }
    ]
}